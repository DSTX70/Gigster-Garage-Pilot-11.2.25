import type { Express, Request, Response } from "express";
import path from "node:path";
import fs from "node:fs";
import { spawn } from "node:child_process";

import { requireRepoOpsToken } from "../lib/i3_drop/auth";
import { parseDropText } from "../lib/i3_drop/parseDrop";
import { applyDropFiles, ApplyMode } from "../lib/i3_drop/applyDrop";

function isSafeRelativePath(p: string): boolean {
  if (!p) return false;
  if (p.includes("\u0000")) return false;
  if (path.isAbsolute(p)) return false;
  const norm = path.posix.normalize(p.replace(/\\/g, "/"));
  if (norm.startsWith("../") || norm.includes("/../") || norm === "..") return false;
  return true;
}

function getReadAllowPrefixes(): string[] {
  // Keep this conservative; expand only if needed.
  const raw = process.env.I3_VERIFY_READ_ALLOWED_PREFIXES_JSON;
  if (raw) {
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed) && parsed.every((x) => typeof x === "string")) return parsed;
    } catch {}
  }
  return ["tools/", "server/", "client/", "README.md", "MISSION.md", "RELEASE_NOTES.md", "MANIFEST.json"];
}

function isAllowedRead(p: string, prefixes: string[]): boolean {
  const norm = p.replace(/\\/g, "/");
  return prefixes.some((pref) => norm === pref || norm.startsWith(pref));
}

async function verifyHttpLocal(args: { urlPath: string; expectStatus?: number; expectContains?: string; timeoutMs?: number }) {
  const port = process.env.PORT || "5000";
  const urlPath = args.urlPath.startsWith("/") ? args.urlPath : `/${args.urlPath}`;
  const url = `http://127.0.0.1:${port}${urlPath}`;

  const expectStatus = typeof args.expectStatus === "number" ? args.expectStatus : 200;
  const expectContains = args.expectContains || "";
  const timeoutMs = typeof args.timeoutMs === "number" ? args.timeoutMs : 4000;

  const ac = new AbortController();
  const to = setTimeout(() => ac.abort(), timeoutMs);

  try {
    const res = await fetch(url, { method: "GET", signal: ac.signal });
    const text = await res.text().catch(() => "");
    const matchedStatus = res.status === expectStatus;
    const matchedContains = expectContains ? text.includes(expectContains) : true;

    return {
      ok: matchedStatus && matchedContains,
      details: {
        url,
        status: res.status,
        expectStatus,
        expectContains,
        matchedStatus,
        matchedContains,
        bodySnippet: text.slice(0, 500),
      },
    };
  } finally {
    clearTimeout(to);
  }
}

function verifyFile(args: { filePath: string; expectContains?: string; maxBytes?: number }) {
  const filePath = args.filePath;
  const expectContains = args.expectContains || "";
  const maxBytes = typeof args.maxBytes === "number" ? args.maxBytes : 65536;

  if (!isSafeRelativePath(filePath)) {
    return { ok: false, details: { error: "Unsafe filePath (absolute or traversal)." } };
  }

  const allow = getReadAllowPrefixes();
  if (!isAllowedRead(filePath, allow)) {
    return { ok: false, details: { error: "filePath not allowed by read allowlist.", allowedPrefixes: allow } };
  }

  const abs = path.resolve(process.cwd(), filePath);
  if (!fs.existsSync(abs)) return { ok: false, details: { error: "File not found.", filePath } };

  const buf = fs.readFileSync(abs);
  const text = buf.slice(0, maxBytes).toString("utf8");
  const matched = expectContains ? text.includes(expectContains) : true;

  return {
    ok: matched,
    details: {
      filePath,
      maxBytes,
      expectContains,
      matched,
      snippet: text.slice(0, 500),
    },
  };
}

export function registerI3DropReceiver(app: Express) {
  app.post("/api/i3/drop/validate", (req: Request, res: Response) => {
    const auth = requireRepoOpsToken(req);
    if (!auth.ok) return res.status(403).json(auth);

    const dropText = String(req.body?.dropText || "");
    const parsed = parseDropText(dropText);
    if (!parsed.ok) return res.status(400).json(parsed);

    return res.json({
      ok: true,
      files: parsed.files.map((f) => ({ path: f.path, bytes: Buffer.byteLength(f.content, "utf8") })),
      warnings: parsed.warnings,
    });
  });

  app.post("/api/i3/drop/apply", (req: Request, res: Response) => {
    const auth = requireRepoOpsToken(req);
    if (!auth.ok) return res.status(403).json(auth);

    const dropText = String(req.body?.dropText || "");
    const mode: ApplyMode = req.body?.mode === "overwrite" ? "overwrite" : "additive";
    const dryRun = Boolean(req.body?.dryRun);

    const parsed = parseDropText(dropText);
    if (!parsed.ok) return res.status(400).json(parsed);

    const repoRoot = path.resolve(process.cwd());
    const out = applyDropFiles(parsed.files, { repoRoot, mode, dryRun });
    return res.json(out);
  });

  // NEW: runtime verification after ship/apply
  app.post("/api/i3/drop/verify", async (req: Request, res: Response) => {
    const auth = requireRepoOpsToken(req);
    if (!auth.ok) return res.status(403).json(auth);

    const kind = String(req.body?.kind || "");

    try {
      if (kind === "http") {
        const urlPath = String(req.body?.urlPath || "");
        if (!urlPath) return res.status(400).json({ ok: false, error: "Missing urlPath" });

        const out = await verifyHttpLocal({
          urlPath,
          expectStatus: typeof req.body?.expectStatus === "number" ? req.body.expectStatus : Number(req.body?.expectStatus),
          expectContains: req.body?.expectContains ? String(req.body.expectContains) : "",
          timeoutMs: typeof req.body?.timeoutMs === "number" ? req.body.timeoutMs : Number(req.body?.timeoutMs),
        });

        return res.json({ ok: out.ok, kind: "http", matched: out.ok, details: out.details });
      }

      if (kind === "file") {
        const filePath = String(req.body?.filePath || "");
        if (!filePath) return res.status(400).json({ ok: false, error: "Missing filePath" });

        const out = verifyFile({
          filePath,
          expectContains: req.body?.expectContains ? String(req.body.expectContains) : "",
          maxBytes: typeof req.body?.maxBytes === "number" ? req.body.maxBytes : Number(req.body?.maxBytes),
        });

        return res.json({ ok: out.ok, kind: "file", matched: out.ok, details: out.details });
      }

      return res.status(400).json({ ok: false, error: "kind must be 'http' or 'file'" });
    } catch (e: any) {
      return res.status(500).json({ ok: false, error: e?.message || String(e) });
    }
  });

  // Runs tools/ship_publish.sh and streams logs
  app.post("/api/i3/drop/ship", (req: Request, res: Response) => {
    const auth = requireRepoOpsToken(req);
    if (!auth.ok) return res.status(403).send(auth.error);

    const verbose = Boolean(req.body?.verbose);

    res.setHeader("Content-Type", "text/plain; charset=utf-8");
    res.setHeader("Transfer-Encoding", "chunked");

    const child = spawn("bash", ["tools/ship_publish.sh"], {
      cwd: process.cwd(),
      env: { ...process.env, VERBOSE: verbose ? "1" : (process.env.VERBOSE || "0") },
      stdio: ["ignore", "pipe", "pipe"],
    });

    res.write(`SHIP: start\nCMD: bash tools/ship_publish.sh\nVERBOSE: ${verbose ? "1" : "0"}\n\n`);
    child.stdout.on("data", (d) => res.write(d));
    child.stderr.on("data", (d) => res.write(d));

    child.on("close", (code) => {
      res.write(`\n\nSHIP: done (exit=${code})\n`);
      res.end();
    });

    child.on("error", (err) => {
      res.write(`\nSHIP: error ${String(err)}\n`);
      res.end();
    });
  });
}
